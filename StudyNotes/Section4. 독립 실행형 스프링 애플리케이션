서블릿과 관련된 코드를 핵심 비즈니스 로직과 완전히 분리하여, 애플리케이션을 개발할 때는 서블릿과 관련된 코드를 신경쓰지 않아도 되게끔 만들어보자.

# 스프링 컨테이너 도입

기존 코드는 프론트 컨트롤러 서블릿이 애플리케이션 빈인 helloController을 new로 직접 생성해서 사용했다. 이번에는 **helloController의 생성과 의존성 주입**을 Spring Container에게 위임한다. 스프링 컨테이너는 애플리케이션 기능을 담은 POJO와 설정 정보를 받아서 빈을 생성하고 서버 애플리케이션으로 띄운다.

```java
// Spring Container에 helloController 빈을 등록하고
// 프론트 컨트롤러에서 빈을 사용하기
public class HellobootApplication {

	public static void main(String[] args) {

		// 스프링 컨테이너 받고 빈 등록
		GenericApplicationContext applicationContext = new GenericApplicationContext(); // 코드로 받은 스프링 컨테이너
		applicationContext.registerBean(HelloController.class); // 구성 정보 등록
		applicationContext.refresh(); // 구성 정보를 바탕으로 컨테이너 초기화

		ServletWebServerFactory serverFactory = new TomcatServletWebServerFactory();
		WebServer webServer = serverFactory.getWebServer(servletContext -> {

			servletContext.addServlet("frontcontroller", new HttpServlet() {

				@Override
				protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

					if (req.getRequestURI().equals("/hello") && req.getMethod().equals(HttpMethod.GET.name())) {
						// req
						String name = req.getParameter("name");

						// 스프링 컨테이너로부터 HelloController 빈 받기
						HelloController helloController = applicationContext.getBean(HelloController.class);
						String ret = helloController.hello(name);

						// resp
						resp.setContentType(MediaType.TEXT_PLAIN_VALUE);
						resp.getWriter().println(ret);
					}
					else {
						resp.setStatus(HttpStatus.NOT_FOUND.value());
					}

				}
			}).addMapping("/*"); // 중앙 처리
		});

		webServer.start();
	}

}
```

애플리케이션 빈의 생성과 의존성 주입을 스프링 컨테이너에 위임했다. 빈의 생성과 관리는 이제 스프링 컨테이너의 책임이다. 우리는 스프링 컨테이너가 애플리케이션 동작에 필요한 빈을 생성하고 관리할 것을 기대한다. 어떻게 생성하고 어떻게 관리할지는 스프링 컨테이너가 결정하는데, 스프링 컨테이너는 빈을 싱글톤 방식으로 관리하고 빈을 이름이나 타입으로 구분한다. new를 사용해 빈을 생성 사용하는 것과 스프링 컨테이너를 두는 것의 차이는 빈의 생성과 관리를 위임함으로써 앞으로 애플리케이션 빈으로 관리될 수많은 객체들을 일관된 방법으로 관리할 수 있는 구조를 만든 것이다.

# Controller와 Service의 분리

컨트롤러에서는 웹 클라이언트의 요청을 검증하고, 응답을 만드는데 필요한 비즈니스 로직을 처리하고, 웹 클라이언트의 응답을 만든다. 이때 비즈니스 로직을 실제로 실행하는 부분은 Service로 분리하고 Controller에서 Service에게 요청을 보내 실행하도록 한다. 결과적으로 컨트롤러는 요청 검증과 응답 생성을 하는 책임을 가지고, 비즈니스 로직을 처리할 수 있는 객체를 아는 책임을 가진다. 분리 전보다 더 단순한 책임을 갖는다.

```java
// 인삿말을 만드는 비즈니스 로직
public class SimpleHelloService {
    String sayHello(String name) {
        return "Hello " + name;
    }
}

// 요청값 name의 유효성 검사
// 인삿말 만드는 비즈니스 로직은 서비스에 요청
public class HelloController {
    public String hello(String name) {
        SimpleHelloService service = new SimpleHelloService();
        return service.sayHello(Objects.requireNonNull(name));
    }
}
```

# Dependency Injection

변경에 유리한 구조를 만들기 위해서는 컴파일 시점의 의존성은 변하지 않으면서 런타임 시점의 의존성을 다르게 주입해야 한다. 인터페이스와 같은 역할을 사용하면 컴파일 시점의 의존성이 변하지 않도록 유지할 수 있으나, 실제 런타임 시점의 의존성을 어딘가에서 결정해주어야한다. 이 작업을 의존성 해결이라고 부르는데, 의존성 주입(DI)가 대표적인 의존성 해결 방법이다.

DI는 의존하는 객체를 외부에서 생성하고 주입하는 방법이다. DI를 하려면 객체 생성과 주입을 담당하는 제 3의 존재가 필요한데, 이를 어셈블러이자 스프링 컨테이너라고 한다. 생성자 수정자 메소드를 이용한 DI를 사용할 수 있다.

위의 컨트롤러 코드에서는 서비스를 생성자로 직접 생성해서 의존하고 있다. 스프링 컨테이너를 도입하여 서비스와 컨트롤러를 빈으로 등록하고 의존성을 주입받을 수 있도록 변경해보자.

확장 가능하도록 서비스 클래스가 인터페이스를 구현하도록 하고, 컨트롤러가 서비스의 인터페이스에 의존하도록 코드를 변경했다. 생성자를 통해 외부에서 의존성을 주입받는다.

```java
public interface HelloService {
    String sayHello(String name);
}

public class SimpleHelloService implements HelloService {
    @Override
    public String sayHello(String name) {
        return "Hello " + name;
    }
}

public class HelloController {
    private final HelloService helloService;

		public HelloController(HelloService helloService) {
        this.helloService = helloService;
    }
		// ..
}
```

이제 의존성을 결정하는 외부를 살펴보자. 프론트 컨트롤러를 띄우기에 앞서 스프링 컨테이너를 얻고 빈을 등록하는 부분이 있었다. 여기에서 HelloController 생성자의 HelloService에 주입되는 구체적인 의존성을 결정한다. SimpleHelloService.class를 등록한다.

```java
public class HellobootApplication {

   public static void main(String[] args) {

      GenericApplicationContext applicationContext = new GenericApplicationContext();
      applicationContext.registerBean(HelloController.class);
      applicationContext.registerBean(SimpleHelloService.class);
      applicationContext.refresh();

```

이때 HelloService.class를 등록하지 않아도 HelloController에서 SimpleHelloService를 잘 찾는다. 스프링 컨테이너가 의존성을 주입할 때 HelloService 타입이 될 수 있는 빈을 찾아 주입하기 때문이다.